---
title: "visualizing_gsva_scores_5"
author: "mleukam"
date: "2020-01-23"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Introduction

## Setup

```{r}
# Clear the workspace
rm(list = ls())
```

```{r}
knitr::opts_chunk$set(eval = FALSE)
```

```{r}
# store base R plotting parameters at startup for later reset
.pardefault <- par(no.readonly = T)

# set seed
set.seed(818)
```

Load packages
```{r}
library("Biobase")
library("factoextra")
library("FactoMineR")
library("ggConvexHull")
library("ggsci")
library("ggpubr")
library("viridis")
library("tidyverse")
library("ComplexHeatmap")
library("caTools")
```

note: after using ggdark, need to restore defaults of fill/color with: 
"invert_geom_defaults()"

Read in combined expression set (for pheno data) and GSVA scores
```{r}
gs_matrix <- readRDS("output/dlbcl_total_immune_gset_v4_results.rds")
gs_matrix[, 1:5]
str(gs_matrix)

combined_es <- readRDS("output/combined_expressionset.rds")
pheno_data <- pData(combined_es)
```


Select gene sets from initial library
```{r}
gset_ids_complete_4 <- readRDS("output/gset_ids_complete_4.rds")
gset_ids_complete_4

names.initial <- names(gset_ids_complete_4) %>%
  enframe() %>%
  dplyr::select(gs_name = value) %>%
  print()

# remove B-cell related gene set names and gene sets used for descriptions of clusters only
# review using View function
# review unpublished uchi_t_inflamed_gs
remove.names <- c("cyt_gs", "dhit_gs", "imsig_bcells_gs", "thor_bcell_mg_igj", "thor_bcell_receptors_score", "thor_b_cell_pca_16704732", "thor_bcell_21978456", 	"thor_gp2_immune_bcell_score", "uchi_t_inflamed_gs")

names.handfiltered <- names.initial %>%
  dplyr::filter(!gs_name %in% remove.names) %>%
  pull(gs_name)
head(names.handfiltered)

gene_sets_1 <- enframe(gset_ids_complete_4) %>%
  dplyr::rename(gs_name_1 = name, genes_1 = value) %>%
  print()

gene_sets_2 <- enframe(gset_ids_complete_4) %>%
  dplyr::rename(gs_name_2 = name, genes_2 = value)

# make a table of pairwise comparisons for gene set names
comb <- combs(names.handfiltered, 2) %>%
  as.data.frame() %>%
  as_tibble() %>%
  dplyr::rename(gs_name_1 = V1, gs_name_2 = V2) %>%
  left_join(gene_sets_1, by = "gs_name_1") %>%
  left_join(gene_sets_2, by = "gs_name_2") %>%
      print()

# define function to find overlap of gene set names
overlappy <- function(genes_1, genes_2){
  prct <- (2 * length(intersect(genes_1, genes_2))) / (length(genes_1) + length(genes_2))
  prct
}

comb_prct <- comb %>% 
  mutate(prct = map2_dbl(genes_1, genes_2, overlappy)) %>%
  arrange(desc(prct)) %>%
  print(n = 100)
hist(comb_prct$prct)

# get a list of gene sets to cut
# will cut gene sets with 2/3 genes shared or more
# 17 gene sets meet the criteria
# since column choice randomly selected, will cut column two
gs_cut <- comb_prct %>%
  dplyr::filter(prct > 0.666) %>%
  pull(gs_name_2) %>%
  print()

names.lessoverlap <- names.handfiltered %>%
  enframe() %>%
  dplyr::select(gs_name = value) %>%
  dplyr::filter(!gs_name %in% gs_cut) %>%
  pull(gs_name)
print(names.lessoverlap)
length(names.lessoverlap)
# n = 121

filt_gs <- enframe(gset_ids_complete_4) %>%
  dplyr::rename(gs_name = name, genes = value) %>%
  dplyr::filter(gs_name %in% names.lessoverlap) %>%
  print()
filt_gs_list <- as.list(filt_gs$genes)
names(filt_gs_list) <- as.character(filt_gs$gs_name)
head(filt_gs_list)
  
raw_score_matrix <- readRDS("output/dlbcl_total_immune_gset_v4_results.rds") %>%
  as.data.frame() %>%
  rownames_to_column(var = "gs_names")
raw_score_matrix[1:5, 1:5]
dim(raw_score_matrix)

score_matrix <- raw_score_matrix %>%
  as_tibble() %>%
  dplyr::filter(gs_names %in% names.lessoverlap) %>%
  as.data.frame() %>%
  column_to_rownames(var = "gs_names") %>%
  t()
score_matrix[1:5, 1:5]
dim(score_matrix)
  
```

Get total number of genes
```{r}
# get a table of final genes in each gene set by filtered gene set name
filt_genes <- enframe(gset_ids_complete_4) %>%
  dplyr::rename(gs_name = name, genes = value) %>%
  dplyr::filter(gs_name %in% names.handfiltered) %>%
  dplyr::filter(!gs_name %in% gs_cut) %>%
  print()

# vector of all genes
genes <- filt_genes %>%
  pull(genes) %>%
  as_vector()

# get number of unique genes
genes %>%
  unique() %>%
  length()

# frequency table
freq_tab <- filt_genes %>%
  unnest() %>%
  group_by(genes) %>%
  count(genes) %>%
  arrange(desc(n)) %>%
  mutate(prop = n / 121) %>%
  print()

# mean frequency
freq_tab %>% pull(n) %>% as.numeric() %>% mean()

# get hugo symbols for genes
# read in conversion table for gene IDs
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo") %>%
  print()
freq_tab_hugo <- freq_tab %>%
  dplyr::rename(gene_id = genes) %>%
  left_join(gencode_gtf) %>%
  dplyr::select(gene_name, n, prop, gene_id) %>%
  print()
```

## Quick Checks

#### Does this clustering separate PD-L1amp cases?

PD-L1 is a known immune inflamed phenotype. Can this clustering method show some grouping of PD-L1 distinct from the background?

```{r}
str(pheno_data)
summary(as.factor(pheno_data$pdl1_status))
pheno_data_tbl <- as.data.frame(pheno_data) %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  mutate(pdl1_status = replace_na(pdl1_status, "not_assessed")) %>%
  mutate(pdl1_status = ifelse(pdl1_status == "non-amplified", 
                              "non_amplified", pdl1_status))

summary(as.factor(pheno_data_tbl$pdl1_status))

group_table <- pheno_data_tbl %>%
  dplyr::select(sample_id, pdl1_status)
group_table

# merge group data into gsva matrix
pdl1_comb_exprs <- as.data.frame(score_matrix) %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  left_join(group_table) %>%
  mutate(pdl1_status = as.factor(pdl1_status)) %>%
  dplyr::select(sample_id, pdl1_status, everything()) %>%
  as.data.frame() %>%
  column_to_rownames(var = "sample_id")
pdl1_comb_exprs[1:5, 1:5]
```

PCA plot of results
```{r}
# remove low amplified and samples not assessed
nrow(pdl1_comb_exprs)
pdl1_comb_exprs_filt <- pdl1_comb_exprs %>%
  rownames_to_column(var = "sample_id") %>%
  dplyr::filter(pdl1_status %in% c("high_amplified", "non_amplified")) %>%
  as.data.frame() %>%
  column_to_rownames(var = "sample_id")
nrow(pdl1_comb_exprs_filt)
pdl1_comb_exprs_filt[1:5, 1:5]

# get PCA values
dlbcl_pca <- PCA(pdl1_comb_exprs_filt[-1], scale.unit = TRUE, graph = FALSE)

# get eigenvalues
eig_val <- get_eigenvalue(dlbcl_pca)
eig_val
fviz_eig(dlbcl_pca, addlabels = TRUE, ylim = c(0, 50))
ind <- get_pca_ind(dlbcl_pca)

pdl1_status <- pdl1_comb_exprs_filt$pdl1_status

# visualize PCA -- white
fviz_pca_ind(dlbcl_pca,
             label = "none",
             habillage = pdl1_comb_exprs_filt$pdl1_status,
             palette = "nejm",
             addEllipses = TRUE,
             ggtheme = theme_classic()) +
  theme(axis.line = element_line(color = "#767676")) +
  ggtitle("Combined Thorsson and new gene sets \nPD-L1amp vs nonamp, NCI data only")

fviz_pca_var(dlbcl_pca, col.var = "contrib",
             gradient.cols = "tron",
             label = "none",
             ggtheme = theme_classic()) + 
  theme(axis.line = element_line(color = "#767676"))
```

#### Is there a batch effect by source of data? 

Set up Duke/NCI groups
```{r}
str(pheno_data)
summary(as.factor(pheno_data$source))
group_table <- as.data.frame(pheno_data) %>%
  rownames_to_column(var = "sample_id") %>%
  dplyr::select(sample_id, source)

# merge group data into gsva matrix
dukenci_comb_exprs <- as.data.frame(score_matrix) %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  left_join(group_table) %>%
  dplyr::select(sample_id, source, everything()) %>%
  as.data.frame() %>%
  column_to_rownames(var = "sample_id") %>%
  mutate(source = as.factor(source))
```

PCA Plot of results
```{r}
# get PCA values
dlbcl_pca <- PCA(dukenci_comb_exprs[-1], scale.unit = TRUE, graph = FALSE)

# get eigenvalues
eig_val <- get_eigenvalue(dlbcl_pca)
eig_val
fviz_eig(dlbcl_pca, addlabels = TRUE, ylim = c(0, 50))
ind <- get_pca_ind(dlbcl_pca)

pdl1_status <- dukenci_comb_exprs$pdl1_status

# visualize PCA -- white
fviz_pca_ind(dlbcl_pca,
             label = "none",
             habillage = dukenci_comb_exprs$source,
             palette = "nejm",
             addEllipses = TRUE,
             ggtheme = theme_classic()) +
  theme(axis.line = element_line(color = "#767676")) +
  ggtitle("Combined Thorsson and new gene sets \nDuke vs NCI data sources")

varplot <- fviz_pca_var(dlbcl_pca, col.var = "contrib",
             gradient.cols = "tron",
             ggtheme = theme_classic2())
varplot

# Contributions of variables to PC1
fviz_contrib(dlbcl_pca, choice = "var", axes = 1, top = 15) + 
  theme_classic2() +
  theme(axis.text.x = element_text(angle = 80, hjust = 1))

# Contributions of variables to PC2
fviz_contrib(dlbcl_pca, choice = "var", axes = 2, top = 15) +
  theme_classic2() +
  theme(axis.text.x = element_text(angle = 80, hjust = 1))

# Contributions of variables to PC3
fviz_contrib(dlbcl_pca, choice = "var", axes = 3, top = 15) +
  theme_classic2() +
  theme(axis.text.x = element_text(angle = 80, hjust = 1))

# Contributions of variables to PC4
fviz_contrib(dlbcl_pca, choice = "var", axes = 4, top = 15) +
  theme_classic2() +
  theme(axis.text.x = element_text(angle = 80, hjust = 1))

# annotate variables
CTL_activity
macrophage_activity
proliferation
plasma_cell
```

#### Heatmap of raw GSVA results
```{r eval=FALSE}
ht <- Heatmap(score_matrix, name = "GSVA Score", 
                row_title = "Gene Sets",
                show_row_names = TRUE,
                column_title = paste0("GSVA scores for Duke and NCI samples"), 
                show_column_names = FALSE,
                column_title_side = "bottom")
ht
```

## Clustering

Determine suitability of data for clustering

First visualize similarity among observations with distance matrix
```{r}
# create pearson correlation matrix
dlbcl_dist <- get_dist(score_matrix, 
                       stand = TRUE,
                       method = "pearson")
```

Plot results
```{r eval=FALSE}
fviz_dist(dlbcl_dist, show_labels = FALSE) +
  scale_fill_viridis() +
  theme(axis.ticks = element_blank(), axis.text = element_blank())

ggsave("docs/assets/fvis_dist_1.png", 
       device = png(),
       width = 6.67, 
       height = 6.67, 
       units = "in")
```

Get Hopkins statistic of clusterability
```{r}
# Compute Hopkins statistic 
# Below 0.5 is considered "clusterable"
library(clustertend)
dlbcl_tend <- hopkins(score_matrix, n = nrow(score_matrix) - 1, header = FALSE)
dlbcl_tend
```

#### Filter out highly correlated gene sets
```{r}
gs_cor <- cor(score_matrix, method = c("pearson"))
library(corrplot)
source("http://www.sthda.com/upload/rquery_cormat.r")
```

```{r eval=FALSE}
# view gene set correlation heatmap
cortables <- rquery.cormat(t(gs_matrix), graphType = "heatmap")
```

```{r}
# reformat gene set correlation table and view
corflat <- rquery.cormat(score_matrix, type = "flatten", graph = FALSE)
corflat_tbl <- corflat$r %>% as_tibble() %>% arrange(desc(cor)) %>% print(n = 30)

# 7 gene sets 0.96 correlation and above. 
removesets <- c("imsig_proliferation_gs", 
                "beijing_cd8_c1_lef1_gs",
                "imsig_interferon_gs",
                "beijing_cd8_c3_cx3cr1_gs",
                "thor_module3_ifn_score",
                "thor_lck_19272155 ",
                "imsig_tcells_gs")

ncol(score_matrix)
gs_matrix_filtered_df <- t(score_matrix) %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_set") %>%
  dplyr::filter(!gene_set %in% removesets)
nrow(gs_matrix_filtered_df)

sample_matrix_filtered <- gs_matrix_filtered_df %>%
  column_to_rownames(var = "gene_set") %>%
  as.matrix() %>%
  t()
sample_matrix_filtered[1:5, 1:5]
dim(sample_matrix_filtered)

# plot results
fviz_dist(dlbcl_dist, show_labels = FALSE) +
  scale_fill_viridis() +
  theme(axis.ticks = element_blank(), axis.text = element_blank())

ggsave("docs/assets/fvis_dist_2.png", 
       device = png(),
       width = 6.67, 
       height = 6.67, 
       units = "in")
```

Repeat similarity among observations with distance matrix
```{r}
# create pearson correlation matrix
dlbcl_dist2 <- get_dist(sample_matrix_filtered, 
                       stand = TRUE, 
                       method = "pearson")
```

Repeat Hopkins statistic of clusterability
```{r}
# Compute Hopkins statistic for iris dataset
# Below 0.5 is considered "clusterable"
dlbcl_tend <- hopkins(sample_matrix_filtered,
                      n = nrow(gs_matrix_filtered_df) - 1, 
                      header = FALSE)
dlbcl_tend
```

Determine optimal number of clusters
```{r}
# Method 1: Elbow Method Using FactoExtra 
fviz_nbclust(sample_matrix_filtered, 
             FUNcluster = kmeans, 
             method = "wss") 

# Method 2: Silhouette in FactoExtra
fviz_nbclust(sample_matrix_filtered, 
             kmeans, method = "silhouette") + 
  theme_classic()

# GAP STAT Using Facto Extra 
fviz_nbclust(sample_matrix_filtered, 
             kmeans, nstart = 25, 
             method = "gap_stat", 
             nboot = 500) + #nboot is # of bootstrap sample - must be included
  labs(subtitle = "Gap Statistic Method")

# summary method: NbClust
nb <- NbClust(sample_matrix_filtered, 
              distance = "euclidean", 
              min.nc = 2, 
              max.nc = 10, 
              method = "kmeans")
```

## Clustering

Divide into groups with HCPC
```{r}
set.seed(818)
dlbcl_pca <- PCA(sample_matrix_filtered, ncp = 10, graph = FALSE)
dlbcl_hcpc <- HCPC(dlbcl_pca, nb.clust = 4)
```

Write out models for later prediction
```{r}
saveRDS(dlbcl_pca, "output/dlbcl_gsva5_4cluster_pca.rds")
saveRDS(dlbcl_hcpc, "output/dlbcl_gsva5_4cluster_hcpc.rds")
```

Get variable plot
```{r}
varplot <- fviz_pca_var(dlbcl_pca, 
             col.var = "contrib",
             gradient.cols = "tron", 
             label = "none",
             ggtheme = theme_classic2())
             
varplot

var_coord <- dlbcl_pca$var$coord %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_set") %>%
  as_tibble() %>%
  print()

ggplot(data = var_coord) +
  coord_polar() +
  geom_segment(aes(x = 0, y = 0, xend = Dim.1))

```
