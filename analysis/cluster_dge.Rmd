---
title: "Differential Gene Expression by Cluster"
author: "mleukam"
date: "2019-07-15"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Setup

Clear the workspace
```{r}
rm(list = ls())
```

Load packages
```{r}
library("tidyverse")
library("Biobase")
library("limma")
library("edgeR")
library("ggdark")
library("ggsci")
library("viridis")
library("sva")
```

Read in data
```{r}
# Combined duke+nci es with gsva4, 4-cluster model phenodata and log-transformed, normalized read counts
combined_es <- readRDS("output/combined_es_gsva4_4cluster.rds")
```

Setup for limma voom linear modeling following limma user's manual https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf

Chapter 15 RNAseq Data

Recommended steps:

1. Start with raw counts (HTSeq or Kallisto for example)
2. Filter for expression
3. TMM normalize
4. Do not log transform
5. Pass batches (sequencing center) to limma voom with precision weights for batch effect modeling

## NCI 

Read in raw counts
```{r}
total_counts <- read_csv("output/nci_dlbcl_unprocessed_counts.csv")

# read in conversion table for gene IDs
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo")
```

#### Filter for protein coding genes
```{r}
# filter for protein coding genes
total_counts_prcode <- total_counts %>%
  dplyr::rename(gene_id = gene) %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::filter(gene_type == "protein_coding") %>%
  dplyr::select(-gene_name, -gene_type, -gene_status, -level, -havana_gene) %>%
  dplyr::select(gene_id, everything())
total_counts_prcode[1:5, 1:5]

nrow(total_counts)
nrow(total_counts_prcode)
```

#### Density plots before expression filtering
```{r eval = FALSE}
tidy_counts <- total_counts_prcode %>% 
  gather(key = "sampleID", value = "intensity", -gene_id) 

dplot1 <- ggplot(tidy_counts, aes(intensity)) +
  geom_density() + 
  theme(legend.position = "none") +
  xlim(-5, 100) +
  ggtitle("Density plot of counts for NCI DLBCL") +
  dark_theme_gray()
dplot1

dplot2 <- ggplot(tidy_counts, aes(log(intensity))) +
  geom_density() +
  theme(legend.position = "none") +
  xlim(-20, 20) +
  ggtitle("Density plot of log(counts) for NCI DLBCL") +
  dark_theme_gray()
dplot2
```

#### Filter by expression levels

Will use CPM for filtering
```{r}
# move gene names to rownames
totcounts_prcode_matrix <- total_counts_prcode %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_id")
totcounts_prcode_matrix[1:5, 1:5]
dim(totcounts_prcode_matrix)

cpm_prcode_matrix <- cpm(totcounts_prcode_matrix, log = FALSE)

# apply hard cutoffs 
# filter out genes that have counts <= 10 in at least half of cases
# count expression cutoff: 10
cutoff <- 1
# set filter fraction
min_sm_frac = 0.5
filter_frac = min_sm_frac * ncol(cpm_prcode_matrix)
filter_frac
total_stats <- data.frame(
  total = apply(cpm_prcode_matrix, 
                1, 
               function(x) {sum(x > cutoff, na.rm = TRUE) } ))
# get indices that meet criteria
keep <- which(total_stats$total >= filter_frac)

# use indices to filter COUNTS MATRIX (not cpm) and check results
dim(totcounts_prcode_matrix)
total_nci_filtered = totcounts_prcode_matrix[keep,]
dim(total_nci_filtered)
total_nci_filtered[1:5, 1:5]
```

#### Density plots after expression filtering
```{r eval = FALSE}
tidy_counts <- total_nci_filtered %>% 
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  gather(key = "sampleID", value = "counts", -gene_id) 

dplot1 <- ggplot(tidy_counts, aes(counts)) +
  geom_density() + 
  theme(legend.position = "none") +
  xlim(-5, 100) +
  ggtitle("Density plot of filtered counts for NCI DLBCL") +
  dark_theme_gray()
dplot1

dplot2 <- ggplot(tidy_counts, aes(log(counts))) +
  geom_density() +
  theme(legend.position = "none") +
  xlim(-20, 20) +
  ggtitle("Density plot of filtered log(counts) for NCI DLBCL") +
  dark_theme_gray()
dplot2
```

## Duke

Read in raw counts for Duke samples as dgelist
```{r}
dgelist <- readRDS("data/temp.dgelist_edger.rds")
str(dgelist)
```

Convert GENCODE v29 to v22 gene ids to match GDC standard
```{r}
# get expression matrix
expr_duke <- dgelist[[1]]
expr_duke[1:5, 1:5]
col__names <- colnames(expr_duke)
col_names_rep <- str_split(col__names, pattern = "\\.", simplify = TRUE) %>% 
  as_tibble() %>%
  pull(V1) %>%
  paste0("duke_", .) %>%
  print()
colnames(expr_duke) <- col_names_rep
expr_duke[1:5, 1:5]

# gencode v29 was used to generate rownames of expr_duke matrix
# GDC standard is gencode v22, which is source of NCI data
# will convert to gencode v22 to match rows of NCI data
geneID_split <- str_split(gencode_gtf$gene_id, pattern = "\\.", simplify = TRUE) %>% 
  as_tibble() %>%
  dplyr::select(geneID_split = V1)

gencode_gtf_split <- gencode_gtf %>% 
  bind_cols(geneID_split) %>%
  dplyr::select(gene_id_v22 = gene_id, geneID_split, everything()) %>%
  print()

row__names <- rownames(expr_duke) %>%
  enframe() %>%
  dplyr::select(geneID_split = value) %>%
  print()

# check how many gene ids are missing in v22 that are named in v29
setdiff(row__names$geneID_split, gencode_gtf_split$geneID_split)
# approx 1900 (previous checks show none after filtering for protein coding genes)

# merge gene name data with expression matrix
expr_duke_df <- expr_duke %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id_v29") %>%
  as_tibble() %>%
  mutate(geneID_split = str_replace(gene_id_v29, pattern = "\\.*", "")) %>%
  dplyr::select(gene_id_v29, geneID_split, everything()) %>%
  left_join(gencode_gtf_split) %>%
  dplyr::select(gene_id_v29, gene_id_v22, geneID_split, gene_type, everything()) %>%
  dplyr::select(-gene_status, -gene_name, -level, -havana_gene) %>%
  print()

# check how many gene ids are missing from version 22  
summary(is.na(expr_duke_df$gene_id_v22))

# check the gene types in the expression matrix
summary(as.factor(expr_duke_df$gene_type))
```

#### Filter for protein coding
```{r}
# filter for protein coding genes only
expr_duke_filtered <- expr_duke_df %>% 
  dplyr::filter(gene_type == "protein_coding")
  
# any missing gene ids also protein coding genes?
summary(is.na(expr_duke_filtered$gene_id_v22))
# NO

expr_duke_protcoding <- expr_duke_filtered %>%
  dplyr::select(-gene_id_v29, -geneID_split, -gene_type) %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_id_v22") %>%
  as.matrix()

str(expr_duke_protcoding)
expr_duke_protcoding[1:5, 1:5]
```

#### Subset cases based on protein coding library coverage

Following recommendation in methods section of Reddy et al Cell 2017 (original data source). They reported including only those libraries containing at least 12,000 protein coding genes.

```{r}
expr_duke_protcoding[1:5, 1:5]

gene_coverage_threshold <- 12000

ncol(expr_duke_protcoding)
expr_duke_subset <- expr_duke_protcoding[, colSums(expr_duke_protcoding != 0) > gene_coverage_threshold]

expr_duke_subset[1:5, 1:5]
ncol(expr_duke_subset)
```

#### Initial density plots
```{r eval = FALSE}
# Density plots
# tidy data
tidy_counts <- t(expr_duke_subset) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  gather(key = "gene_id", value = "counts", -sample_id) %>%
  print()

# plots
dplot_duke <- ggplot(tidy_counts, aes(counts)) +
  geom_density() + 
  theme(legend.position = "none") +
  dark_theme_gray()
dplot_duke +
  xlim(-5, 100)

# plot with log and small offset
dplot_duke_log <- ggplot(tidy_counts, aes(log(counts + 0.5))) +
  geom_density() + 
  theme(legend.position = "none") +
  dark_theme_gray()
dplot_duke_log +
  xlim(-10, 10)

```

#### Filtering by expression
Will use CPM for filtering
```{r}
cpm_duke_subset <- cpm(expr_duke_subset, log = FALSE)

# apply hard cutoffs 
# filter out genes that have counts <= 10 in at least half of cases
# count expression cutoff: 10
cutoff <- 1
# set filter fraction
min_sm_frac = 0.5
filter_frac = min_sm_frac * ncol(cpm_duke_subset)
filter_frac
total_stats <- data.frame(
  total = apply(cpm_duke_subset, 
                1, 
               function(x) {sum(x > cutoff, na.rm = TRUE) } ))
# get indices that meet criteria
keep <- which(total_stats$total >= filter_frac)

# use indices to filter COUNTS MATRIX (not cpm) and check results
dim(expr_duke_subset)
total_duke_filtered <- expr_duke_subset[keep,]
dim(total_duke_filtered)
total_duke_filtered[1:5, 1:5]
```

#### Post-filtering density plots
```{r eval = FALSE}
# Density plots
# tidy data
tidy_filtered <- t(total_duke_filtered) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  gather(key = "gene_id", value = "counts", -sample_id) %>%
  print()

# plots
dplot_duke_2 <- ggplot(tidy_filtered, aes(counts)) +
  geom_density() + 
  theme(legend.position = "none") +
  dark_theme_gray() +
  ggtitle("Density plot of Duke raw counts after expression filtering")
dplot_duke_2 +
  xlim(-5, 100)

# plot with log and small offset
dplot_duke_log_2 <- ggplot(tidy_filtered, aes(log(counts + 0.5))) +
  geom_density() + 
  theme(legend.position = "none") +
  dark_theme_gray() +
  ggtitle("Density plot of Duke log(counts) after expression filtering")
dplot_duke_log_2 +
  xlim(-10, 10)
```

## Merge

#### Combine expression data

```{r}
duke_exprs <- total_duke_filtered %>% 
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  dplyr::select(gene_id, everything()) %>%
  print()

nci_exprs <- total_nci_filtered %>% 
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  dplyr::select(gene_id, everything()) %>%
  print()

# filter rownames to only keep intersecting rows
duke_genes <- duke_exprs %>% pull(gene_id)
length(duke_genes)
nci_genes <- nci_exprs %>% pull(gene_id)
length(nci_genes)

combined_genes <- intersect(duke_genes, nci_genes)
length(combined_genes)
head(combined_genes)

duke_exprs_filt <- duke_exprs %>%
  dplyr::filter(gene_id %in% combined_genes)
nrow(duke_exprs_filt)

nci_exprs_filt <- nci_exprs %>%
  dplyr::filter(gene_id %in% combined_genes)
nrow(nci_exprs_filt)

combined_exprs_df <- nci_exprs_filt %>%
  left_join(duke_exprs_filt, by = "gene_id") %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_id")
combined_exprs_df[1:5, 1:5]
```

#### Normalize gene expression distributions

Normalisation by the method of trimmed mean of M-values is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. 
```{r}
# will do below on the dge
# get normalization factors
# norm_factors <- calcNormFactors(combined_exprs_df, method = "TMM")

# apply factor to each column - not necessary for limma
# norm_exprs <- map2_dfc(combined_exprs_df, norm_factors, `*`)
# norm_exprs <- as.data.frame(norm_exprs)
# rownames(norm_exprs) <- rownames(combined_exprs)

combined_exprs <- combined_exprs_df %>% as.matrix()
combined_exprs[1:5, 1:5]
```

#### Reformat pheno data to match

```{r}
pheno_data_tbl <- pData(combined_es) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  dplyr::select(sample_id, 127:198) %>%
  dplyr::select(-alpha_var) %>%
  as_tibble() %>%
  print()

samplenames <- pheno_data_tbl %>% pull(sample_id)
length(samplenames)
columnnames <- colnames(combined_exprs)
length(columnnames)
identical(samplenames, columnnames)

pheno_data <- pheno_data_tbl %>%
  as.data.frame() %>%
  column_to_rownames(var = "sample_id")
```

## DGE by cluster

The contrast matrix for the differential gene expression will be to compare each cluster to all other clusters)

Contrast matrix bioC forum question: https://support.bioconductor.org/p/26251/

General contrast coding: https://stats.idre.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/#DEVIATION

Contrast coding for linear models in R (detailed instructions on custom matrix): https://stats.stackexchange.com/questions/52252/how-to-specify-a-contrast-matrix-in-r-for-the-difference-between-one-level-and

#### Limma
```{r}
# create DGEList
dge <- DGEList(counts = combined_exprs)

# apply TMM normalization to DGE
dge <- calcNormFactors(dge)

# set up design matrix
# include sequencing center as a batch variable to the model
rnames <- colnames(combined_es)
groups <- pData(combined_es) %>% 
  pull(clust) %>%
  paste0("cluster_", .) %>%
  as.factor()
batch <- pData(combined_es) %>%
  pull(source) %>%
  as.factor
design <- model.matrix(~ 0 + groups + batch)
rownames(design) <- rnames
head(design)

# write out DGElist and design
saveRDS(dge, "output/dgelist_for_limma.rds")
saveRDS(design, "output/design_for_limma.rds")
```

Limma voom with quality weights - run on a cluster
```{r eval = FALSE}
## See code folder in github repo for full script
# read in data
dge <- readRDS("/gpfs/data/kline-lab/inputs/dgelist_for_limma.rds")
design <- readRDS("/gpfs/data/kline-lab/inputs/design_for_limma.rds")

# voom transformation is applied to the normalized and filtered DGEList object
v <- voomWithQualityWeights(dge, 
                            design, 
                            plot = TRUE, 
                            normalize = "quantile")

# fit linear model and estimate DGE
fit <- lmFit(v, design)

# write out results
saveRDS <- saveRDS(v, "/gpfs/data/kline-lab/tcga_macs/output/limma_voom_elist_1.rds")

saveRDS <- saveRDS(fit, "/gpfs/data/kline-lab/tcga_macs/output/limma_voom_marraylmfit.rds")
```

Read in results
```{r}
v <- readRDS("output/limma_voom_elist_1.rds")
fit <- readRDS("output/limma_voom_marraylmfit.rds")
```


DGE Cluster 1
```{r}
# set up contrast matrix
contr_matrix_c1 <- makeContrasts("clust_1_vs_others" = groupscluster_1 - (groupscluster_2 + groupscluster_3 + groupscluster_4) / 3, 
  levels = colnames(design))
contr_matrix_c1

# use contrast matrix and eBayes to estimate SEM and pvalues
fit_c1 <- contrasts.fit(fit, contr_matrix_c1)
fit_c1 <- eBayes(fit_c1)

cluster1_dge <- topTable(fit_c1, 
                         adjust.method = "BH", 
                         sort.by = "none", 
                         number = Inf)

top50_cluster1_dge_up <- cluster1_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(desc(logFC)) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()

top50_cluster1_dge_down <- cluster1_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(logFC) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()
```

DGE Cluster 2
```{r}
# set up contrast matrix
contr_matrix_c2 <- makeContrasts("clust_1_vs_others" = groupscluster_2 - (groupscluster_1 + groupscluster_3 + groupscluster_4) / 3, 
  levels = colnames(design))
contr_matrix_c2

# use contrast matrix and eBayes to estimate SEM and pvalues
fit_c2 <- contrasts.fit(fit, contr_matrix_c2)
fit_c2 <- eBayes(fit_c2)

cluster2_dge <- topTable(fit_c2, 
                         adjust.method = "BH", 
                         sort.by = "none", 
                         number = Inf)

top50_cluster2_dge_up <- cluster2_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(desc(logFC)) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()

top50_cluster2_dge_down <- cluster2_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(logFC) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()
```

DGE Cluster 3
```{r}
# set up contrast matrix
contr_matrix_c3 <- makeContrasts("clust_1_vs_others" = groupscluster_3 - (groupscluster_1 + groupscluster_2 + groupscluster_4) / 3, 
  levels = colnames(design))
contr_matrix_c3

# use contrast matrix and eBayes to estimate SEM and pvalues
fit_c3 <- contrasts.fit(fit, contr_matrix_c3)
fit_c3 <- eBayes(fit_c3)

cluster3_dge <- topTable(fit_c3, 
                         adjust.method = "BH", 
                         sort.by = "none", 
                         number = Inf)

top50_cluster3_dge_up <- cluster3_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(desc(logFC)) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()

top50_cluster3_dge_down <- cluster3_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(logFC) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()
```

DGE Cluster 4
```{r}
# set up contrast matrix
contr_matrix_c4 <- makeContrasts("clust_1_vs_others" = groupscluster_4 - (groupscluster_1 + groupscluster_2 + groupscluster_3) / 3, 
  levels = colnames(design))
contr_matrix_c4

# use contrast matrix and eBayes to estimate SEM and pvalues
fit_c4 <- contrasts.fit(fit, contr_matrix_c4)
fit_c4 <- eBayes(fit_c4)

cluster4_dge <- topTable(fit_c4, 
                         adjust.method = "BH", 
                         sort.by = "none", 
                         number = Inf)

top50_cluster4_dge_up <- cluster4_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(desc(logFC)) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()

top50_cluster4_dge_down <- cluster4_dge %>%
  rownames_to_column(var = "gene_id") %>%
  left_join(gencode_gtf) %>%
  arrange(logFC) %>%
  dplyr::slice(1:50) %>%
  dplyr::select(gene_name, logFC, adj.P.Val) %>%
  print()
```

## Visualizations
```{r}
library(EnhancedVolcano)
## Change to gene names
cluster4_dge_names <- cluster4_dge %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::distinct(gene_name, .keep_all = TRUE) %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_name") %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene) 

head(cluster4_dge_names)

## Plot
EnhancedVolcano(
  toptable = cluster4_dge_names,
  lab = rownames(cluster4_dge_names),
  x = "logFC",
  y = "P.Value",
  pCutoff = 0.05,
  FCcutoff = 1.5, 
  legendPosition = "none",
  title = "DGE: Inflamed cluster vs all others",
  transcriptPointSize = 1.5
  
)

```

## Write out data

```{r}
saveRDS(counts_es, "output/counts_expressionset_for_limma.rds")
```

```{r}
saveRDS(cluster1_dge, "output/cluster1_dge.rds")
saveRDS(cluster2_dge, "output/cluster2_dge.rds")
saveRDS(cluster3_dge, "output/cluster3_dge.rds")
saveRDS(cluster4_dge, "output/cluster4_dge.rds")
```

