---
title: "Pathway analysis of differentially expressed genes by cluster"
author: "mleukam"
date: "2019-07-16"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

# Setup

Clear the workspace
```{r}
rm(list = ls())
```

```{r}
knitr::opts_chunk$set(eval = FALSE)
```

Load basic packages
```{r}
library("tidyverse")
library("fgsea")
library("org.Hs.eg.db")
library("msigdbr")
```

Read in data
```{r}
# toptables
cluster1_dge <- readRDS("output/nci_cluster1_dge.rds")
cluster2_dge <- readRDS("output/nci_cluster2_dge.rds")
cluster3_dge <- readRDS("output/nci_cluster3_dge.rds")
cluster4_dge <- readRDS("output/nci_cluster4_dge.rds")

ttable_list <- list(cluster1_dge, cluster2_dge, cluster3_dge, cluster4_dge)
names(ttable_list) <- c("cluster1_dge", "cluster2_dge", "cluster3_dge", "cluster4_dge")

# lookup table for gene names
# read in conversion table for gene IDs
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo")
```

# GO Enrichment

#### GO with TopGO

https://bioconductor.org/packages/release/bioc/vignettes/topGO/inst/doc/topGO.pdf

#### GO with clusterProfiler

Vignettes and tutorials from the author used to generate this analysis:
https://guangchuangyu.github.io/2016/01/go-analysis-using-clusterprofiler/
https://yulab-smu.github.io/clusterProfiler-book/chapter5.html

Load packages
```{r}
library("clusterProfiler")
```

Prepare data - input for enrichGO test is simple vector of gene names
Will pass gene names that meet cutoff criteria for adj.p.val and logFC from DGE experiment.

Add Entrez identifiers to gencode lookup table
```{r}
gencode_symbols <- gencode_gtf %>%
  pull(gene_name)
  
entrez <- mapIds(org.Hs.eg.db, gencode_symbols, 'ENTREZID', 'SYMBOL') %>%
  enframe() %>%
  dplyr::rename(gene_name = name, entrez_id = value) %>%
  print()

gencode_ent <- gencode_gtf %>%
  left_join(entrez) %>%
  print()
```

Decide which genes to use for enrichment
```{r}
# set adjusted pval cutoff
p_cut <- 0.001

# see range of fold-changes
summary(ttable_list[[1]]$logFC)
summary(ttable_list[[2]]$logFC)
summary(ttable_list[[3]]$logFC)
summary(ttable_list[[4]]$logFC)

# set logFC cutoff at average of 3rd quartile fold-change (upregulated genes only)
l_cut <- (0.2683903 + 0.167624 + 0.106894 + 0.1939774) / 4

# get gene list of entrez IDs that pass cutoff for each cluster from DGE
go_gene_list <- ttable_list %>%
  map(function(df){rownames_to_column(df, var = "gene_id")}) %>%
  map(as_tibble) %>%
  map(function(df){df %>% 
      dplyr::filter(adj.P.Val < p_cut) %>%
      dplyr::filter(logFC > l_cut)}) %>%
  map(function(df){left_join(df, gencode_ent)}) %>%
  map(function(df){pull(df, entrez_id)})

str(go_gene_list)

# get gene universe list (same for all clusters)
go_gene_universe <- ttable_list[[1]] %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_ent) %>%
  pull(entrez_id)
str(go_gene_universe)
```

```{r}
# get enriched/overrepresented GO lists for cluster 1 DGE
ego1 <- enrichGO(gene = go_gene_list[[1]],
                 OrgDb = org.Hs.eg.db,
                 ont = "BP",
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 universe = go_gene_universe,
                 qvalueCutoff = 0.1)
# http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/

# convert to gene names
ego1 <- setReadable(ego1, OrgDb = org.Hs.eg.db)

# plot
dotplot(ego1, showCategory = 30)

ego1_simp <- clusterProfiler::simplify(ego1, 
                      cutoff = 0.7,
                      by = "p.adjust",
                      select_fun = min)

dotplot(ego1_simp)
```

```{r}
# get enriched/overrepresented GO lists for cluster 2 DGE
ego2 <- enrichGO(gene = go_gene_list[[2]],
                 OrgDb = org.Hs.eg.db,
                 ont = "BP",
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 universe = go_gene_universe,
                 qvalueCutoff = 0.1)
# http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/

# convert to gene names
ego2 <- setReadable(ego2, OrgDb = org.Hs.eg.db)

# plot
dotplot(ego2, showCategory = 30)

ego2_simp <- clusterProfiler::simplify(ego2, 
                      cutoff = 0.7,
                      by = "p.adjust",
                      select_fun = min)

dotplot(ego2_simp)
```

```{r}
# get enriched/overrepresented GO lists for cluster 3 DGE
ego3 <- enrichGO(gene = go_gene_list[[3]],
                 OrgDb = org.Hs.eg.db,
                 ont = "BP",
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 universe = go_gene_universe,
                 qvalueCutoff = 0.1)
# http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/

# convert to gene names
ego3 <- setReadable(ego3, OrgDb = org.Hs.eg.db)

# plot
dotplot(ego3, showCategory = 30)

ego3_simp <- clusterProfiler::simplify(ego3, 
                      cutoff = 0.7,
                      by = "p.adjust",
                      select_fun = min)

dotplot(ego3_simp)
```

```{r}
# get enriched/overrepresented GO lists for cluster 3 DGE
ego4 <- enrichGO(gene = go_gene_list[[4]],
                 OrgDb = org.Hs.eg.db,
                 ont = "BP",
                 pvalueCutoff = 0.05,
                 pAdjustMethod = "BH",
                 universe = go_gene_universe,
                 qvalueCutoff = 0.1)
# http://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/

# convert to gene names
ego4 <- setReadable(ego4, OrgDb = org.Hs.eg.db)

# plot
dotplot(ego4, showCategory = 30)

ego4_simp <- clusterProfiler::simplify(ego4, 
                      cutoff = 0.7,
                      by = "p.adjust",
                      select_fun = min)

dotplot(ego4_simp)
```

# FGSEA

#### Rank lists

Filtering by FC and adjusted P-value
```{r}
# Adjusted p-value cutoff
p_cut <- 0.01

# filter for p value
nrow(ttable_list[[1]])
ttable_df_list <- ttable_list %>%
  map(function(df){rownames_to_column(df, var = "gene_id")}) %>%
  map(as_tibble) %>%
  map(function(df){df %>% 
      dplyr::filter(adj.P.Val < p_cut)})

# how many significantly different genes left?
nrow(ttable_df_list[[1]])
nrow(ttable_df_list[[2]])
nrow(ttable_df_list[[3]])
nrow(ttable_df_list[[4]])
```

http://www.bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html

Create ranked lists following this tutorial: https://bioinformatics-core-shared-training.github.io/cruk-summer-school-2018/RNASeq2018/html/06_Gene_set_testing.nb.html

Downloading gene sets from MSigDB: https://cran.r-project.org/web/packages/msigdbr/vignettes/msigdbr-intro.html


```{r}
# define function for creating ranked lists
ranklist <- function(df){
  ranks <- df %>%
    rownames_to_column(var = "gene_id") %>%
    left_join(gencode_ent) %>%
    dplyr::select(entrez_id, logFC) %>%
    mutate(logFC = as.double(logFC)) %>%
    drop_na(entrez_id)
  rank_vector <- ranks %>% pull(logFC)
  names(rank_vector) <- ranks %>% pull(entrez_id)
  rank_vector
}

# apply to list of top tables
rtable_list <- map(ttable_list, ranklist)
rtable_list[[1]]
str(rtable_list)
```

```{r}
# get gene sets from MSigDB
m_df = msigdbr(species = "Homo sapiens")

# format  gene sets as a list of character vectors of entrez gene names
gs_df <- m_df %>%
  mutate(gs_idname = paste0(gs_cat, ".", gs_id, ".", gs_name)) %>%
  dplyr::select(gs_idname, entrez_gene) %>%
  nest(data = entrez_gene) %>%
  arrange(desc(gs_idname))

gs_list <- map(gs_df$data, pull) %>%
  map(as.character)
names(gs_list) <- gs_df$gs_idname
str(gs_list)

# start with just the hallmark gene sets for testing
hall_gs_subset <- gs_df %>%
  dplyr::filter(grepl("^H", gs_idname))

hall_gs_list <- map(hall_gs_subset$data, pull) %>%
  map(as.character)
names(hall_gs_list) <- hall_gs_subset$gs_idname
str(hall_gs_list)
```

#### GSEA

```{r}
# define function to run hallmark gsea on each toptable
library(BiocParallel)

fgsea_hallmark <- function(ranklist){
  temp <- fgsea(pathways = hall_gs_list, 
                                  stats = ranklist,
                                  minSize = 15, 
                                  maxSize = 500,
                                  nperm = 10000)
  
  collapsedPathways <- collapsePathways(temp[order(pval)][padj < 0.01],
                                        hall_gs_list, 
                                        ranklist)
  mainPathways <- temp[pathway %in% collapsedPathways$mainPathways][
                         order(-NES)]
  mainPathways
}

# apply function to list of cluster toptables
hallmark_gsea_results <- map(rtable_list, fgsea_hallmark)

# review results
# review results
map(hallmark_gsea_results, function(df){as_tibble(df) %>% 
    dplyr::filter(padj < 0.01) %>% 
    dplyr::select("pathway", "ES", "padj") %>% 
    arrange(desc(ES))})

```

```{r}
# define function to run gsea on each toptable
fgsea_batch <- function(ranklist){
  temp <- fgsea(pathways = gs_list, 
                                  stats = ranklist,
                                  minSize = 15, 
                                  maxSize = 500,
                                  nperm = 10000)
  
  collapsedPathways <- collapsePathways(temp[order(pval)][padj < 0.01],
                                        gs_list, 
                                        ranklist)
  mainPathways <- temp[pathway %in% collapsedPathways$mainPathways][
                         order(-NES)]
  mainPathways
}

# apply function to list of cluster toptables
gsea_results <- map(rtable_list, fgsea_batch)

# review results
map(gsea_results, function(df){as_tibble(df) %>% 
    dplyr::select("pathway", "ES", "padj") %>% 
    arrange(desc(ES))})
```

Write out results for use in Cytoscape
```{r}
gsea_cluster1 <- gsea_results[[1]] %>% as_tibble() 
lead <- map_chr(gsea_cluster1$leadingEdge, function(list){
  paste(list, collapse = ",")
  })
gsea_cluster1$leadingEdge <- lead
gsea_cluster1

write_csv(gsea_cluster1, "output/gsea_res_cluster1.csv")

```


Example code for collapsing pathways:
http://www.bioconductor.org/packages/release/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html

Will instead handle the analysis and visualization of results with the EnrichmentMap App in Cytoscape 3.7.

https://enrichmentmap.readthedocs.io/en/latest/

Another option for functional annotation:
http://genescf.kandurilab.org/documentation.php
http://genescf.kandurilab.org/ftp/GeneSCF-Documentation_v1.1.pdf

A third option for network analysis:
https://www.networkanalyst.ca/NetworkAnalyst/resources/tutorials/t2a_single_list.pdf

Prepare data for GSEA desktop app

RNK file format: https://software.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats

```{r}
# Column names need to start with `#` or just don't have any
# Recommend Hugo Gene symbdols
enframe(rtable_list[[1]]) %>% 
  dplyr::rename(entrez_id = name) %>%
  left_join(gencode_ent) %>%
  drop_na(gene_name) %>%
  dplyr::select(`#HGNC_symbol` = gene_name, logFC = value) %>%
  write_delim("output/clust1_vs_others_dge.rnk", delim = "\t", col_names = FALSE)

enframe(rtable_list[[2]]) %>% 
  dplyr::rename(entrez_id = name) %>%
  left_join(gencode_ent) %>%
  drop_na(gene_name) %>%
  dplyr::select(`#HGNC_symbol` = gene_name, logFC = value) %>%
  write_delim("output/clust2_vs_others_dge.rnk", delim = "\t", col_names = FALSE)

enframe(rtable_list[[3]]) %>% 
  dplyr::rename(entrez_id = name) %>%
  left_join(gencode_ent) %>%
  drop_na(gene_name) %>%
  dplyr::select(`#HGNC_symbol` = gene_name, logFC = value) %>%
  write_delim("output/clust3_vs_others_dge.rnk", delim = "\t", col_names = FALSE)

enframe(rtable_list[[4]]) %>% 
  dplyr::rename(entrez_id = name) %>%
  left_join(gencode_ent) %>%
  drop_na(gene_name) %>%
  dplyr::select(`#HGNC_symbol` = gene_name, logFC = value) %>%
  write_delim("output/clust4_vs_others_dge.rnk", delim = "\t", col_names = FALSE)
```

#### Hallmark gene sets

```{r}
# Get hallmark gene sets from MSigDb (human)
msigdbr_show_species()
m_df = msigdbr(species = "Homo sapiens", category = "H")
m_df

# format for fgsea
gs_list_hallmark = m_df %>% 
  split(x = .$gene_symbol, f = .$gs_name)
str(gs_list_hallmark)

# Get all human gene sets for relevant biological processes
# Include Hallmark and curated C2 biological process sets
# Exclude chromosome position gene sets
# Exclude miRNA / regulatory motif gene sets
# Include GO terms (C5)
# Include computational gene sets from cancer microarray data (C4)
# Include microarray 'oncogenic' signatures
# Include immunologic signatures, manual curation from human and mouse studies (C7)
m_df_total = msigdbr(species = "Homo sapiens") %>%
  dplyr::filter(gs_cat %in% c("H", "C2", "C4", "C5", "C7"))
m_df_total

# get number of gene sets in each category
summary(as.factor(m_df_total$gs_cat))

# format for fgsea
gs_list_total = m_df_total %>% 
  split(x = .$gene_symbol, f = .$gs_name)
str(gs_list_total)
```

```{r}
# read in toptables
cluster1_dge <- readRDS("output/cluster1_dge.rds")
cluster2_dge <- readRDS("output/cluster2_dge.rds")
cluster3_dge <- readRDS("output/cluster3_dge.rds")
cluster4_dge <- readRDS("output/cluster4_dge.rds")
```

Source for GSEA file prep (supplemental method 1): https://www.nature.com/articles/s41596-018-0103-9
Reimand et al "Pathway enrichment analysis and visualization of omics data using g:Profiler, GSEA, Cytoscape and EnrichmentMap" Nature Methods Jan 2019

Create a two-column rank (.RNK) file of all gene IDs and corresponding scores to for GSEA pre-ranked analysis. To run GSEA in pre-ranked mode, you need a two column RNK file with gene/protein/probe name (column 1) and the associated score (column 2). The first column should contain the same type of gene IDs used in the pathway gene-set (GMT) file. GSEA will look for enrichment in the set of most differentially
expressed genes at the top of the list as well as those at the bottom of the list. Genes at the top of the list are more highly expressed in class A of samples while genes at the bottom are highly expressed in class B. A score can be computed by multiplying direction (sign) of fold change and logarithm of p-value for each gene.

```{r}
# change gene ids to gene symbol
cluster1_dge_names <- cluster1_dge %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::distinct(gene_name, .keep_all = TRUE) %>%
  dplyr::select(gene_name, everything()) %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene) 
cluster1_dge_names

cluster2_dge_names <- cluster2_dge %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::distinct(gene_name, .keep_all = TRUE) %>%
  dplyr::select(gene_name, everything()) %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene) 
cluster2_dge_names

cluster3_dge_names <- cluster3_dge %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::distinct(gene_name, .keep_all = TRUE) %>%
  dplyr::select(gene_name, everything()) %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene) 
cluster3_dge_names

cluster4_dge_names <- cluster4_dge %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  left_join(gencode_gtf, by = "gene_id") %>%
  dplyr::distinct(gene_name, .keep_all = TRUE) %>%
  dplyr::select(gene_name, everything()) %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene) 
cluster4_dge_names

# calculate ranks
ranks_clust1 <- sign(cluster1_dge_names$logFC) * -log10(cluster1_dge_names$P.Value)
names(ranks_clust1) <- cluster1_dge_names$gene_name
ranks_clust1 <- sort(ranks_clust1, decreasing = TRUE)
head(ranks_clust1)
tail(ranks_clust1)
summary(duplicated(names(ranks_clust1)))

ranks_clust2 <- sign(cluster2_dge_names$logFC) * -log10(cluster2_dge_names$P.Value)
names(ranks_clust2) <- cluster2_dge_names$gene_name
ranks_clust2 <- sort(ranks_clust2, decreasing = TRUE)
head(ranks_clust2)
tail(ranks_clust2)
summary(duplicated(names(ranks_clust2)))

ranks_clust3 <- sign(cluster3_dge_names$logFC) * -log10(cluster3_dge_names$P.Value)
names(ranks_clust3) <- cluster3_dge_names$gene_name
ranks_clust3 <- sort(ranks_clust3, decreasing = TRUE)
head(ranks_clust3)
tail(ranks_clust3)
summary(duplicated(names(ranks_clust3)))

ranks_clust4 <- sign(cluster4_dge_names$logFC) * -log10(cluster3_dge_names$P.Value)
names(ranks_clust4) <- cluster4_dge_names$gene_name
ranks_clust4 <- sort(ranks_clust4, decreasing = TRUE)
head(ranks_clust4)
tail(ranks_clust4)
summary(duplicated(names(ranks_clust4)))
```

#### Hallmark GSEA

Source: http://bioconductor.org/packages/devel/bioc/vignettes/fgsea/inst/doc/fgsea-tutorial.html

Purrr functions

```{r}
library(BiocParallel)

fgsea_hallmark <- function(ranks){
  temp <- fgsea(pathways = gs_list_hallmark, 
                                  stats = ranks,
                                  minSize = 15, 
                                  maxSize = 500,
                                  nperm = 10000)
  
  collapsedPathways <- collapsePathways(temp[order(pval)][padj < 0.01],
                                        gs_list_hallmark, 
                                        ranks)
  mainPathways <- temp[pathway %in% collapsedPathways$mainPathways][
                         order(-NES)]
  mainPathways
}

# test function
ranks <- ranks_clust1
fgsea_hallmark(ranks)[1:5, 1:5]

# make list of rank stat vectors
ranklist <- list(ranks_clust1,
                 ranks_clust2,
                 ranks_clust3, 
                 ranks_clust4)
                 

# apply function to list
hallmark_results <- map(ranklist, fgsea_hallmark)

# display function
mainpaths <- function(df){
  pathways <- df %>% pull(pathway)
  pathways
}

# apply display function to results
map(hallmark_results, mainpaths)

# plots
pathways1 <- hallmark_results[[1]] %>% 
  arrange(desc(abs(NES))) %>% 
  pull(pathway)
ranks = ranklist[[1]]
plot1 <- plotGseaTable(gs_list_hallmark[pathways1], 
                       ranks, 
                       hallmark_results[[1]])

pathways2 <- hallmark_results[[2]] %>% 
  arrange(desc(abs(NES))) %>% 
  pull(pathway)
ranks = ranklist[[2]]
plot2 <- plotGseaTable(gs_list_hallmark[pathways2], 
                       ranks, 
                       hallmark_results[[2]])

pathways3 <- hallmark_results[[3]] %>% 
  arrange(desc(abs(NES))) %>% 
  pull(pathway)
ranks = ranklist[[3]]
plot3 <- plotGseaTable(gs_list_hallmark[pathways3], 
                       ranks, 
                       hallmark_results[[3]])

pathways4 <- hallmark_results[[4]] %>% 
  arrange(desc(abs(NES))) %>% 
  pull(pathway)
ranks = ranklist[[4]]
plot4 <- plotGseaTable(gs_list_hallmark[pathways4], 
                       ranks, 
                       hallmark_results[[4]])
```

#### Larger collection of gene sets
```{r}
fgsea_total <- function(ranks){
  temp <- fgsea(pathways = gs_list_total, 
                                  stats = ranks,
                                  minSize = 15, 
                                  maxSize = 500,
                                  nperm = 10000)
  
  collapsedPathways <- collapsePathways(temp[order(pval)][padj < 0.01],
                                        gs_list_total, 
                                        ranks)
  mainPathways <- temp[pathway %in% collapsedPathways$mainPathways][
                         order(abs(NES))]
  mainPathways
}

# test function
ranks <- ranks_clust1
fgsea_total(ranks)[1:5, 1:5]

# make list of rank stat vectors
ranklist <- list(ranks_clust1,
                 ranks_clust2,
                 ranks_clust3, 
                 ranks_clust4)

# apply function to list
total_results <- map(ranklist, fgsea_total)

# display function
mainpaths <- function(df){
  pathways <- df %>% pull(pathway)
  pathways
}

# apply display function to results
map(total_results, mainpaths)

# plots
pathways1 <- total_results[[1]] %>% 
  arrange(abs(NES)) %>% 
  dplyr::slice(1:20) %>% 
  pull(pathway)
ranks <- ranklist[[1]]
plot1 <- plotGseaTable(gs_list_total[pathways1], 
                       ranks, 
                       total_results[[1]])
```
