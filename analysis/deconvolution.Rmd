---
title: "deconvolution"
author: "mleukam"
date: "2019-07-11"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Setup
Clear the workspace
```{r}
rm(list = ls())
```

Load packages
```{r}
library("tidyverse")
library("edgeR")
library("limma")
library("Biobase")
library("preprocessCore")
library("ggsci")
library("ggdark")
library("viridis")
library("ggpubr")
```

## xCell deconvolution

#### Prepare data

Instructions for data preparation:

http://xcell.ucsf.edu/

> The rownames should be gene symbols. If the data contains non-unique gene symbols, rows with same gene symbols will be averaged. xCell uses the expression levels ranking and not the actual values, thus normalization does not have an effect, however normalizing to gene length (RPKM/FPKM/TPM/RSEM) is required.

> Importantly, xCell performs best with heterogenous dataset. Thus it is recommended to use all data combined in one run, and not break down to pieces (especially not cases and control in different runs).

I will use the logCPM normalized and batch-corrected expression matrix in the "combined_es" expressionset. All that is left to do is convert the gencode rownames to Hugo gene symbols.

```{r}
# load data
combined_es <- readRDS("output/combined_expressionset.rds")

# format 
expr_df <- exprs(combined_es) %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  print()

expr_symbol <- expr_df %>%
  left_join(gencode_gtf) %>%
  dplyr::select(gene_name, everything()) %>%
  dplyr::select(-gene_id, -gene_type, -gene_status, -level, -havana_gene)

expr_data_matrix <- expr_df[, 2:1190] %>%
  as.matrix()

rownames(expr_data_matrix) <- pull(expr_symbol, gene_name)

expr_data_matrix[1:5, 1:5]

# average values with duplicate gene names
nrow(expr_data_matrix)
expr_symbol_cleaned <- avereps(expr_data_matrix)
nrow(expr_symbol_cleaned)
summary(isUnique(rownames(expr_symbol_cleaned)))

# write out for use in xCell (use non-tidyverse function to preserve rownames)
write.csv(expr_symbol_cleaned, "output/xcell_input_matrix.csv")
```

Submitted to web portal 7/18/2019

#### Xcell results
```{r}
xc_results <- read_delim("output/xCell_xcell_input_matrix_xCell_1039071819.txt", "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  dplyr::rename(cell_type = X1) %>% 
  as.data.frame() %>%
  column_to_rownames(var = "cell_type") %>%
  as.matrix %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  print()

# read in cluster assignments
gsva4_es <- readRDS("output/combined_es_gsva4_4cluster.rds")
clust_assgn <- pData(gsva4_es) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  dplyr::select(sample_id, clust) %>%
  as_tibble() %>%
  print()

# add to dataframe
xc_results_clust <- xc_results %>%
  left_join(clust_assgn) %>%
  dplyr::select(sample_id, clust, everything()) %>%
  print()

# quick look at cytotoxic T-cells
xc_results_clust %>%
  group_by(clust) %>%
  summarize(mean(`CD8+ T-cells`))

# transform data for boxplot
xc_tidy <- xc_results_clust %>%
  gather(key = "cell_type", value = "xc_score", -clust, -sample_id) %>%
  print()

# select cell types of interest
keepers <- c("CD4+ T-cells", "CD8+ T-cells", "DC", "Eosinophils", "Macrophages", "Macrophages M1", "Macrophages M2", "Th1 cells", "Th2 cells", "Tregs")

xc_tidy_filt <- xc_tidy %>%
  dplyr::filter(cell_type %in% keepers)

# boxplot
total_boxplot <- ggplot(xc_tidy_filt, aes(x = cell_type, y = xc_score)) +
  geom_boxplot(aes(fill = cell_type)) +
  facet_wrap("clust") +
  ylab("xCell scores") +
  xlab("Cell type") +
  ggtitle("Immune Cell Deconvolution of Combined DLBCL Samples") +
  dark_theme_gray() +
  scale_color_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

total_boxplot
```

#### Additional plots

Tips on ANOVA: http://www.sthda.com/english/wiki/one-way-anova-test-in-r
Tips on significance bars: https://www.r-bloggers.com/add-p-values-and-significance-levels-to-ggplots/

```{r}
xc_tidy_cd8 <- xc_tidy %>%
  dplyr::filter(cell_type == "CD8+ T-cells")

# boxplot
cd8_boxplot <- ggplot(xc_tidy_filt, aes(x = clust, y = xc_score)) +
  geom_boxplot(aes(fill = clust)) +
  ylab("xCell scores") +
  xlab("Cluster") +
  ggtitle("Immune Cell Deconvolution of CD8 T-cells") +
  dark_theme_gray() +
  scale_color_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

cd8_boxplot

# significance testing
group_by(xc_tidy_cd8, clust) %>%
  summarise(
    count = n(),
    mean = mean(xc_score, na.rm = TRUE),
    sd = sd(xc_score, na.rm = TRUE)
  )

# Compute the analysis of variance
compare_means(xc_score ~ clust, 
              data = xc_tidy_cd8,
              method = "anova")

my_comparisons <- list(c("1", "4"), 
                       c("2", "4"), 
                       c("3", "4"))

# boxplot with significance testing
cd8_boxplot_sig <- ggplot(xc_tidy_cd8, aes(x = clust, y = xc_score)) +
  geom_boxplot(aes(fill = clust)) +
  ylab("xCell scores") +
  xlab("Cluster") +
  ggtitle("Immune Cell Deconvolution of CD8 T-cells") +
  dark_theme_gray() +
  scale_color_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     ref.group = ".all.",
                     label.y = 0.58) +
  geom_hline(yintercept = mean(xc_tidy_cd8$xc_score), 
             linetype = 2) +
  stat_compare_means(method = "anova", label.y = -0.05)

cd8_boxplot_sig

```

```{r}
xc_tidy_mac <- xc_tidy %>%
  dplyr::filter(cell_type == "Macrophages")

# significance testing
group_by(xc_tidy_mac, clust) %>%
  summarise(
    count = n(),
    mean = mean(xc_score, na.rm = TRUE),
    sd = sd(xc_score, na.rm = TRUE)
  )

# Compute the analysis of variance
compare_means(xc_score ~ clust, 
              data = xc_tidy_mac,
              method = "anova")

# boxplot with significance testing
mac_boxplot_sig <- ggplot(xc_tidy_mac, aes(x = clust, y = xc_score)) +
  geom_boxplot(aes(fill = clust)) +
  ylab("xCell scores") +
  xlab("Cluster") +
  ggtitle("Immune Cell Deconvolution of Total Macrophages") +
  dark_theme_gray() +
  scale_color_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     ref.group = ".all.",
                     label.y = 0.31) +
  geom_hline(yintercept = mean(xc_tidy_mac$xc_score), 
             linetype = 2) +
  stat_compare_means(method = "anova", label.y = -0.05)

mac_boxplot_sig

```

```{r}
xc_tidy_dc <- xc_tidy %>%
  dplyr::filter(cell_type == "DC")

# significance testing
group_by(xc_tidy_dc, clust) %>%
  summarise(
    count = n(),
    mean = mean(xc_score, na.rm = TRUE),
    sd = sd(xc_score, na.rm = TRUE)
  )

# Compute the analysis of variance
compare_means(xc_score ~ clust, 
              data = xc_tidy_dc,
              method = "anova")

# boxplot with significance testing
dc_boxplot_sig <- ggplot(xc_tidy_dc, aes(x = clust, y = xc_score)) +
  geom_boxplot(aes(fill = clust)) +
  ylab("xCell scores") +
  xlab("Cluster") +
  ggtitle("Immune Cell Deconvolution of Dendritic Cells") +
  dark_theme_gray() +
  scale_color_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  stat_compare_means(label = "p.signif", 
                     method = "t.test",
                     ref.group = ".all.",
                     label.y = 0.2) +
  geom_hline(yintercept = mean(xc_tidy_dc$xc_score), 
             linetype = 2) +
  stat_compare_means(method = "anova", label.y = -0.02)

dc_boxplot_sig
```

# Abandoned strategies
Investigated TIMER and MuSiC, but decided not to use in the current analysis. Code is preserved for record-keeping.

## Prepare counts for TIMER
https://cistrome.shinyapps.io/timer/

### Duke data

#### Read in data
```{r eval=FALSE}
total_counts <- read_csv("output/nci_dlbcl_unprocessed_counts.csv")
```

Duke data (raw reads estimated by Kallisto)
See [analysis/dukedata.Rmd](dukedata.html) for creation of DGE list from kallisto output files

See `/code/` for source code of Kallisto analysis from raw sequences

```{r eval=FALSE}
dgelist <- readRDS("data/temp.dgelist_edger.rds")
str(dgelist)
```

read in conversion table for gene IDs
```{r eval=FALSE}
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo")
```

#### Data cleaning

Convert GENCODE v29 to gene symbols for TIMER
```{r eval=FALSE}
# get expression matrix
expr_duke <- dgelist[[1]]
expr_duke[1:5, 1:5]
col__names <- colnames(expr_duke)
col_names_rep <- str_split(col__names, pattern = "\\.", simplify = TRUE) %>% 
  as_tibble() %>%
  pull(V1) %>%
  paste0("duke_", .) %>%
  print()
colnames(expr_duke) <- col_names_rep
expr_duke[1:5, 1:5]

# format gencode table for left join
geneID_split <- str_split(gencode_gtf$gene_id, pattern = "\\.", simplify = TRUE) %>% 
  as_tibble() %>%
  dplyr::select(geneID_split = V1)

gencode_gtf_split <- gencode_gtf %>% 
  bind_cols(geneID_split) %>%
  dplyr::select(gene_id_v22 = gene_id, geneID_split, everything()) %>%
  print()

# left join, select columns, reformat
expr_duke_df <- expr_duke %>%
  as.data.frame() %>%
  rownames_to_column(var = "geneID_split") %>%
  as_tibble() %>%
  left_join(gencode_gtf_split) %>%
  dplyr::select(gene_name, starts_with("duke")) %>%
  drop_na(gene_name) %>%
  as.data.frame()

# merge duplicate entries for genes (average expression)
nrow(expr_duke_df)
expr_duke_data <- as.matrix(expr_duke_df[, 2:772])
rownames(expr_duke_data) <- expr_duke_df[,1]
expr_duke_nodups <- avereps(expr_duke_data)
nrow(expr_duke_nodups)
expr_duke_nodups[1:5, 1:5]
```

Filter samples to match those included in the clustering analysis
```{r eval=FALSE}
duke_es <- readRDS("output/duke_expressionset.rds")
prior_duke_expr <- exprs(duke_es)
samplelist <- c("gene_symbol", colnames(prior_duke_expr))

expr_duke_decon <- expr_duke_nodups %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_symbol") %>%
  as_tibble() %>%
  dplyr::select(one_of(samplelist)) %>%
  column_to_rownames(var = "gene_symbol") %>%
  as.matrix()

dim(expr_duke_decon)
str(expr_duke_decon)
expr_duke_decon[1:5, 1:5]
```

### NCI

Read in NCI raw counts
```{r eval=FALSE}
total_counts <- read_csv("output/nci_dlbcl_unprocessed_counts.csv")
```

Convert gene id to gene symbol, eliminate duplicates
```{r eval=FALSE}
tot_counts_symbol <- total_counts %>%
  dplyr::rename(gene_id = gene) %>%
  left_join(gencode_gtf) %>%
  dplyr::select(gene_name, starts_with("DLBCL")) %>%
  drop_na(gene_name)

tot_counts_matrix <- tot_counts_symbol[, 2:482] %>%
  as.matrix() 
rownames(tot_counts_matrix) <- tot_counts_symbol$gene_name
 
dim(tot_counts_matrix)
str(tot_counts_matrix)
tot_counts_matrix[1:5, 1:5]

# eliminate duplicates by averaging counts
# merge duplicate entries for genes (average expression)
expr_nci_nodups <- avereps(tot_counts_matrix, ID = rownames(tot_counts_matrix))
nrow(expr_nci_nodups)
expr_nci_nodups[1:5, 1:5]
```

### Merge

There are more rows in the NCI dataset after removal of duplicates and missing gene symbols. Will keep only those rows present in both datasets to allow for fair comparison. 

```{r eval=FALSE}
nci_counts_df <- expr_nci_nodups %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_symbol") %>%
  as_tibble()

duke_counts_df <- expr_duke_nodups %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_symbol") %>%
  as_tibble()

merge_counts_df <- nci_counts_df %>%
  inner_join(duke_counts_df) %>%
  print()

## Write out for use in TIMER online application
merge_counts <- merge_counts_df %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_symbol") %>%
  as.matrix()

write.csv(merge_counts, "output/merged_raw_counts.csv")
```

Limit on TIMER upload to 50 MB, total size of CSV now is ~ 231 MB. Will need to split into parts. Leave a little overlap to correct for any batch effect (would not expect any due to per-sample analysis)

```{r eval=FALSE}
ncol(merge_counts) / 5

mc1 <- merge_counts[, 1:250]
rownames(mc1) <- rownames(merge_counts)
write.csv(mc1, "output/merged_raw_counts_1.csv")
mc2 <- merge_counts[, 240:500]
rownames(mc2) <- rownames(merge_counts)
write.csv(mc2, "output/merged_raw_counts_2.csv")
mc3 <- merge_counts[, 490:650]
rownames(mc3) <- rownames(merge_counts)
write.csv(mc3, "output/merged_raw_counts_3.csv")
mc4 <- merge_counts[, 640:800]
rownames(mc4) <- rownames(merge_counts)
write.csv(mc4, "output/merged_raw_counts_4.csv")
mc5 <- merge_counts[, 790:950]
rownames(mc5) <- rownames(merge_counts)
write.csv(mc5, "output/merged_raw_counts_5.csv")
mc6 <- merge_counts[, 940:1100]
rownames(mc6) <- rownames(merge_counts)
write.csv(mc6, "output/merged_raw_counts_6.csv")
mc7 <- merge_counts[, 1090:1252]
rownames(mc7) <- rownames(merge_counts)
write.csv(mc7, "output/merged_raw_counts_7.csv")
```

### TIMER results
```{r eval=FALSE}
mc1 <- read_csv("output/mc1_score_matrix.csv")
mc2 <- read_csv("output/mc2_score_matrix.csv")
mc3 <- read_csv("output/mc3_score_matrix.csv")
mc4 <- read_csv("output/mc4_score_matrix.csv")
mc5 <- read_csv("output/mc5_score_matrix.csv")
mc6 <- read_csv("output/mc6_score_matrix.csv")
mc7 <- read_csv("output/mc7_score_matrix.csv")

combined_scores <- mc1 %>%
  bind_rows(mc2, mc3, mc4, mc5, mc6, mc7) %>%
  arrange(sampleID) %>%
  as.data.frame()

combined_score_matrix_norm <- combined_scores[, 2:7] %>%
  as.matrix() %>%
  normalize.quantiles()

rownames(combined_score_matrix_norm) <- combined_scores %>% pull(sampleID)
# reviewed matrix using the View function in R studio - batch effects were persistent. Given the effort necessary to correct this issue, I will try another, newer deconvolution method that can process the whole matrix at once.
```

## MuSiC

https://www-nature-com.proxy.uchicago.edu/articles/nmeth.1830
Use non-transformed (raw counts) for deconvolution

http://xuranw.github.io/MuSiC/articles/MuSiC.html

```{r}
# install devtools if necessary
#install.packages('devtools')

# install the MuSiC package
#devtools::install_github('xuranw/MuSiC')

# load
#library(MuSiC)
```
